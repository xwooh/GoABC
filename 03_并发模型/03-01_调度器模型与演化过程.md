# Goroutine 调度器模型与演化流程

调度模型预算法演化：

1.   G-M 模型 => G-P-M 模型
2.   不支持抢占 => 协作式抢占 => 基于信号的异步抢占

## G-M 模型

-   G：Goroutine 在运行时的抽象结构。
-   M(machine)：执行 G 的操作系统线程抽象。

调度器的工作就是将 G 调度到 M 上运行，通过 `GOMAXPROCS` 变量表示 Go 调度器可见的“处理器”的最大数量。

这个模型主要的不足：

-   单一全局互斥锁和集中状态存储的存在，导致所有 Goroutine 相关操作都要上锁，比如创建、重新调度等。
-   M 之间把“可运行”的 G 传来传去，导致调度延迟增大，也增加了额外的性能损耗
-   每个 M 都要缓存调度到的 G，如果 G 在 M 之间频繁传递，内存占用浪费
-   由于系统调用（syscall）而形成的频繁工作线程阻塞和解除阻塞，导致额外的性能损耗

**怎么看起来，G-M 模型和普通的多线程没太大区别。**

## G-P-M 模型

### 大体概念

G 和 M 之间加了一层 P。

G 想要运行不直接给到 M 了，而是先给到 P 的一个本地运行队列（local runq），然后 P 再和 M 打交道，把 runq 里面的 P 喂给 M。

**这不就是常见的生产者-消费者模型吗。**

M 从 runq 中获取 G 是无锁的。但是从全局队列取 G 是有全局锁的。

一开始，G-P-M 模型不支持抢占式调度，也就是说，如果某个 G 中有段死循环代码，那么分配给这个 G 的 P 和 M 将永久被占用，从而位于同一个 P 中的其他 G 将得不到调度，出现“饿死”的情况。

极端情况，如果此时只有一个 P（GOMAXPROCS=1），那整个 Go 程序中的所有其他 G 都将“饿死”。



所以在 Go1.2 中实现了基于协作的抢占式调度。

解决办法是让 Go 编译器在每个函数或方法的入口处加了一段额外代码（runtime.morestack_noctxt），让运行时有机会在这段代码中检查是否需要执行抢占式调度。

但是因为只在函数调用的地方插入了“抢占”代码，对于没有函数调用而是纯算法循环计算的 G，调度器依然无法抢占。



Go1.14 中，增加了非协作的抢占式调度支持。这种调度是基于系统信号的，通过向线程发送信号的方式来抢占正在运行的 Goroutine。

### 具体模型

-   G：代表 Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态、Goroutine 的任务函数等，而且 G 对象是可以重用的
-   P：代表逻辑 Processor，P 的数量决定了系统内最大可并行的 G 的数量，P 的最大作用还是其拥有的各种 G 对象队列、链表、一些缓存和状态
-   M：代表真正的执行计算资源，绑定了有效 P 之后，进入一个循环调度。M 不保留 G 的状态，这也是 G 可以跨 M 调度的基础。
    1.   从 P 的本地运行队列以及全局队列中获取 G
    2.   切换到 G 的执行栈上并执行 G 的函数
    3.   调用 goexit 做清理工作并回到 M



如果 G 运行的时候阻塞在了常规文件IO，那此时执行调用 G 的 M 也会跟着 G 一起挂起（OS 要求，Go 运行时无力回天）。

而对于类似网络 IO 的阻塞，挂起的只是 G，G 会被扔到某个等待队列中，M 会空闲出来尝试执行 P 中的下一个可运行 G，如果此时 P 中无可运行的 G，M 会和这个 P 解绑。等 IO 完成 G 会从等待队列中出来，标记为可运行，并进入某个 P 的队列，等到下一次被某个 M 执行。